<h1 id="util">Util</h1>
<h2 id="normalizetext"><code>normalizeText</code></h2>
<p>Converts strings to some special characters, such as three periods to an ellipsis</p>
<pre><code class="language-js">let str = normalizeText(str)</code></pre>
<h2 id="titleize"><code>titleize</code></h2>
<p>Converts underscores and dashes to spaces and then capitlizes each word</p>
<pre><code class="language-js">let str = normalizeText(&#39;my_string&#39;) // My String</code></pre>
<h2 id="sortstring"><code>sortString</code></h2>
<p>Moves the leading article to the end (also strips leading and trailing quotes)</p>
<pre><code class="language-js">sortString(&#39;The Book Title&#39;) // Book Title, The
sortString(&#39;&quot;A Book Title&quot;&#39;) // Book Title, A

// disable quote strip
sortString(&#39;&quot;A Book Title&quot;&#39;, false) // &quot;A Book Title&quot;</code></pre>
<h2 id="promise-series"><code>Promise.series</code></h2>
<p>Perform a set of promise tasks in series (waiting to complete until moving on to the next)</p>
<pre><code class="language-js">import &#39;util/promise.series&#39; // import once

Promise.series([task1, task2, task3], task=&gt;{
    await task()
})

// return `false` at any time to cancel the series
Promise.series([task1, task2, task3], (task,i)=&gt;{
    if( i &gt; 0 ) return false // cancel the series
    await task()
})</code></pre>
<h2 id="device"><code>device</code></h2>
<p>Some simple device detection</p>
<pre><code class="language-js">import device from &#39;util/device&#39;

device.is_ios
device.is_android
device.is_mobile</code></pre>
<h2 id="store"><code>store</code></h2>
<p>Simplified method for using <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage">localStorage</a>; automatically encodes and decodes JSON.</p>
<pre><code class="language-js">store(key, val)

// set
store(&#39;my-setting&#39;, {some:&#39;setting&#39;, another:&#39;setting&#39;})

// get
let mySetting = store(&#39;my-setting&#39;)

// clear
store(&#39;my-setting&#39;, null)</code></pre>
<h2 id="sum"><code>sum</code></h2>
<p>Wrapper around <code>Array.reduce</code> for summing the values in an array.
Will automatically be added to the prototype of Array</p>
<pre><code class="language-js">import &#39;util/sum&#39; // only needs to be done once

[1,2].sum() // = 3
[{val:1}, {val: 2}].sum(o=&gt;o.val) // = 3</code></pre>
<h2 id="wait"><code>wait</code></h2>
<p>Promise based setTimeout</p>
<pre><code class="language-js">await wait(ms) // default is zero which will let the event loop finish
await wait(1000) // wait 1 second</code></pre>
<h2 id="tocsv"><code>toCSV</code></h2>
<p>Convert an array of data to a CSV string (or tab delimited)</p>
<pre><code class="language-js">let data = [{title: &#39;title 1&#39;, info: &#39;info&#39;}, {title: &#39;title 2&#39;, info: &#39;info&#39;}]
let csvData = toCSV(data, {title: &#39;My Data&#39;})</code></pre>
<h4 id="options">Options</h4>
<ul>
<li><code>delimiter: &#39;,&#39;</code></li>
<li><code>newline: &quot;\n&quot;</code></li>
<li><code>title: &#39;&#39;</code> - title at the top of the csv data</li>
<li><code>description: &#39;&#39;</code> - similar to title ^ </li>
<li><code>header: true</code> - show header row?</li>
</ul>
<h4 id="downloading">Downloading</h4>
<p>Use something like <a href="https://github.com/eligrey/FileSaver.js">file-saver</a> to download the csv</p>
<pre><code class="language-js">import {saveAs} from &#39;file-saver&#39;
let blob = new Blob([csvData], {type:&#39;text/csv&#39;});
saveAs(blob, &#39;filename.csv&#39;)</code></pre>
<h2 id="csvtoarray"><code>csvToArray</code></h2>
<p>Convert a CSV string to an array</p>
<pre><code class="language-js">let data = csvToArray(str)</code></pre>
<h2 id="readfile"><code>readFile</code></h2>
<p>Read a <a href="https://developer.mozilla.org/en-US/docs/Web/API/File">file</a> to text (async)</p>
<pre><code class="language-js">let text = await readFile(file)</code></pre>
<h2 id="ajax"><code>AJAX</code></h2>
<p>A wrapper around <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest">XMLHttpRequest</a> to simplify and provide async/await. </p>
<blockquote>
<p><code>fetch</code> is a good solution most of the time, but does not provide progress.</p>
</blockquote>
<pre><code class="language-js">let formData = new FormData()

formData.set(&#39;file&#39;, FileObject)

new AJAX(method, url)
.on(&#39;progress&#39;, e=&gt;{
    let progress = Math.round(e.loaded / e.total * 100)
    console.log(progress)
})
.send(formData)
.then(resp=&gt;{
    console.log(resp)
})</code></pre>
<p>The <code>.on</code> method provides a chainable version of <code>target.addEventListener</code></p>
<pre><code class="language-js">new AJAX(method, url)
.on(&#39;loadstart&#39;, handler)
.on(&#39;progress&#39;, handler)
.send()</code></pre>
<h2 id="background-resume">Background Resume</h2>
<pre><code class="language-js">import &#39;bui/util/background-resume&#39;

window.addEventListener(&#39;background-resume&#39;, e=&gt;{ /*do something*/ })</code></pre>
<p>iOS devices (untested on Android) stop processing JS
when backgrounded for a few seconds (10-20 in my testing)</p>
<p>When the browser is reopended, safari resumes with the JS &quot;state&quot;
intact but since time was essentially frozen, no updates (long poll)
would have been made or received (websocket).</p>
<p>It may be important to trigger a refresh of data when resuming 
from the background; this script enables such a function.</p>
<h2 id="touch-events">Touch Events</h2>
<p><code>bindLongpress</code><br>Mobile/touch devices do not have right+click abilities. In many cases, a long press can
be good alternative. By default, <code>bindLongPress</code> will trigger a <code>contextmenu</code> event
after the user has touched down for <code>500ms</code> without dragging.</p>
<pre><code class="language-js">import {bindLongPress} from &#39;bui/util/touch-events&#39;

bindLongPress(el) // use defaults
bindLongPress(el, {
    event: &#39;contextmenu&#39;, // (default) what event to fire after long press
    delay: 500 // (default) how long until triggering event
})</code></pre>
